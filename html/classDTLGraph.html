<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>TERA: DTLGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TERA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classDTLGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DTLGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DTLGraph_8h_source.html">DTLGraph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1BestScoreArgs.html">BestScoreArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1CountTLsArgs.html">CountTLsArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDTLGraph_1_1EdgeProperties.html">EdgeProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1PrintArgs.html">PrintArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1PrintReconsArgs.html">PrintReconsArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1RemoveArgs.html">RemoveArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph_1_1TimeConsistentReconsArgs.html">TimeConsistentReconsArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDTLGraph_1_1VertexProperties.html">VertexProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9d551ab4081bb68aba57bb315246a7a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d551ab4081bb68aba57bb315246a7a6"></a>
typedef <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="structDTLGraph_1_1VertexProperties.html">VertexProperties</a>, <a class="el" href="structDTLGraph_1_1EdgeProperties.html">EdgeProperties</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a9d551ab4081bb68aba57bb315246a7a6">MyGraph</a></td></tr>
<tr class="memdesc:a9d551ab4081bb68aba57bb315246a7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">graph type <br /></td></tr>
<tr class="separator:a9d551ab4081bb68aba57bb315246a7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a59d412dd5aba9801006f2fc402bdbf69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a59d412dd5aba9801006f2fc402bdbf69">DTLGraph</a> (bool suboptimal, bool pareto, <a class="el" href="classMySpeciesTree.html">MySpeciesTree</a> *speciesTree, <a class="el" href="classCladesAndTripartitions.html">CladesAndTripartitions</a> *cladesTrips)</td></tr>
<tr class="separator:a59d412dd5aba9801006f2fc402bdbf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28266600aeb31b14fec38d8e7f74bd19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a28266600aeb31b14fec38d8e7f74bd19">addPairVertex</a> (MyGraph::Vertex eventVertex, int id_u, int id_x, double cost, MyGraph::Vertex &amp;pairVertex)</td></tr>
<tr class="separator:a28266600aeb31b14fec38d8e7f74bd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22e846b18be0dbd538a3779115859a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ae22e846b18be0dbd538a3779115859a1">addPairVertex</a> (MyGraph::Vertex eventVertex, int id_u, int id_x, double cost, int d, int t, int l, MyGraph::Vertex &amp;pairVertex)</td></tr>
<tr class="separator:ae22e846b18be0dbd538a3779115859a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2835ea04e5f5113f31db428978ea5721"><td class="memItemLeft" align="right" valign="top">MyGraph::Vertex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a2835ea04e5f5113f31db428978ea5721">addEventVertex</a> (MyGraph::Vertex z, string event)</td></tr>
<tr class="separator:a2835ea04e5f5113f31db428978ea5721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6242513734d9c65d80da9e042bd03df"><td class="memItemLeft" align="right" valign="top">MyGraph::Vertex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa6242513734d9c65d80da9e042bd03df">addRoot</a> (int id_u, int id_x, double cost, int d=-1, int t=-1, int l=-1)</td></tr>
<tr class="separator:aa6242513734d9c65d80da9e042bd03df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30691e1ecd335aaaaefe30a1bfe4130b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a30691e1ecd335aaaaefe30a1bfe4130b">countReconciliationNumberAndCheck</a> (double epsilon, bool onlyCanonical, bool verbose, bool weighted)</td></tr>
<tr class="separator:a30691e1ecd335aaaaefe30a1bfe4130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a95dc61d064b6c91785ef41dc553c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ac9a95dc61d064b6c91785ef41dc553c6">pruneNonoptimal</a> ()</td></tr>
<tr class="separator:ac9a95dc61d064b6c91785ef41dc553c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf50ab0c5534af0bbc58018be4270cad"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aaf50ab0c5534af0bbc58018be4270cad">getBestScore</a> (int problem)</td></tr>
<tr class="separator:aaf50ab0c5534af0bbc58018be4270cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1c65174bb829583704140da3db6dc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a7d1c65174bb829583704140da3db6dc7">getScoredReconciliation</a> (int problem, size_t cladeCount, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, bool random=false)</td></tr>
<tr class="separator:a7d1c65174bb829583704140da3db6dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac913b28e5f28d1840b9eec21881b29e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ac913b28e5f28d1840b9eec21881b29e6">countTLs</a> (double &amp;frequency)</td></tr>
<tr class="separator:ac913b28e5f28d1840b9eec21881b29e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bbc12ff0c7009dcdf6924043aaa32e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a01bbc12ff0c7009dcdf6924043aaa32e">checkTimeConsistencies</a> (int limit, bool checkAll=false)</td></tr>
<tr class="separator:a01bbc12ff0c7009dcdf6924043aaa32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f4daa5c06ca87a8f91b5e584099522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a85f4daa5c06ca87a8f91b5e584099522">printGraph</a> (string path, bool useInternalIds, bool cleanGraph=false)</td></tr>
<tr class="separator:a85f4daa5c06ca87a8f91b5e584099522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61265536ac61f7cacd3034019ad8bbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#af61265536ac61f7cacd3034019ad8bbc">orthologyOutput</a> (string fileName)</td></tr>
<tr class="separator:af61265536ac61f7cacd3034019ad8bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9fc9011d848a896928597079b5e2d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aff9fc9011d848a896928597079b5e2d0">printReconciliation</a> (string problemStr, string fileName, bool sylvxFormat, bool checkConsistent, bool &amp;isConsistent, map&lt; string, double &gt; &amp;eventSupports)</td></tr>
<tr class="separator:aff9fc9011d848a896928597079b5e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd4fd3dab8fa8dd60dacfd2d0b5e5de"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a0cd4fd3dab8fa8dd60dacfd2d0b5e5de">printAllReconciliations</a> (string path, bool sylvxFormat, bool checkConsistent, int limit=0)</td></tr>
<tr class="separator:a0cd4fd3dab8fa8dd60dacfd2d0b5e5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66350deee56392e7450333be41b2ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa66350deee56392e7450333be41b2ca1">getEventSupports</a> (map&lt; string, double &gt; &amp;eventSupports)</td></tr>
<tr class="separator:aa66350deee56392e7450333be41b2ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cc9a3c914298d7ae264cef0bde1f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a96cc9a3c914298d7ae264cef0bde1f89">getVertexIdentfiers</a> (MyGraph::Vertex vertex, int &amp;id_u, int &amp;id_x, double &amp;cost, int &amp;d, int &amp;t, int &amp;l)</td></tr>
<tr class="separator:a96cc9a3c914298d7ae264cef0bde1f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51906543c06da66e1791758a8f5144a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a51906543c06da66e1791758a8f5144a6">getNumberSolutions</a> (bool weighted=true)</td></tr>
<tr class="separator:a51906543c06da66e1791758a8f5144a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3931b5b64666214f0f3a5be6c2cac87e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a3931b5b64666214f0f3a5be6c2cac87e">getVertexIdentfiers</a> (MyGraph::Vertex vertex, int &amp;id_u, int &amp;id_x, double &amp;cost)</td></tr>
<tr class="separator:a3931b5b64666214f0f3a5be6c2cac87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd83830e8ff9fb07fa6644f65c38189"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a5fd83830e8ff9fb07fa6644f65c38189">getVertexName</a> (MyGraph::Vertex vertex)</td></tr>
<tr class="separator:a5fd83830e8ff9fb07fa6644f65c38189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd4992ee1587673528a21be05233ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a7dd4992ee1587673528a21be05233ab7">printReconciliationHali</a> (<a class="el" href="classMyGeneTree.html">MyGeneTree</a> &amp;geneTree, vector&lt; int &gt; &amp;pOrdToClade, string outDir, string extensionId, bool triplets=false)</td></tr>
<tr class="separator:a7dd4992ee1587673528a21be05233ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4e79d62d7706994409932ff97821ccc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a4e79d62d7706994409932ff97821ccc6">SCORE_EQUAL</a> (double a, double b)</td></tr>
<tr class="separator:a4e79d62d7706994409932ff97821ccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc65049ffb1053d8a0f7759070289eb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#abc65049ffb1053d8a0f7759070289eb1">SCORE_GREATER</a> (double a, double b)</td></tr>
<tr class="separator:abc65049ffb1053d8a0f7759070289eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e47a0503029779208530f73b1ee010"><td class="memItemLeft" align="right" valign="top">MyGraph::Vertex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a58e47a0503029779208530f73b1ee010">createPairVertex</a> (int id_u, int id_x, double cost, int d=-1, int t=-1, int l=-1)</td></tr>
<tr class="separator:a58e47a0503029779208530f73b1ee010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af511e62318d075642c95dea1d953c3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#af511e62318d075642c95dea1d953c3ee">depthFirstTraversalAux</a> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args, void(DTLGraph::*discoverVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;), void(DTLGraph::*finishVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;))</td></tr>
<tr class="separator:af511e62318d075642c95dea1d953c3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab980c487b7c269f5f6e714b5e7852ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ab980c487b7c269f5f6e714b5e7852ec5">depthFirstTraversal</a> (<a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args, void(DTLGraph::*discoverVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;), void(DTLGraph::*finishVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;))</td></tr>
<tr class="separator:ab980c487b7c269f5f6e714b5e7852ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0a6158981a93bda1fafe890986e752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ade0a6158981a93bda1fafe890986e752">breadthFirstTraversalAux</a> (MyGraph::Vertex z, bool isRoot, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args, void(DTLGraph::*discoverVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;), void(DTLGraph::*finishVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;))</td></tr>
<tr class="separator:ade0a6158981a93bda1fafe890986e752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ec25cce8e2c4b3c2e4a6a0867cde2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a68ec25cce8e2c4b3c2e4a6a0867cde2b">breadthFirstTraversal</a> (<a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args, void(DTLGraph::*discoverVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;), void(DTLGraph::*finishVertexPtr)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;))</td></tr>
<tr class="separator:a68ec25cce8e2c4b3c2e4a6a0867cde2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa978c6dc54acc44f3d0003fbebff97"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a3fa978c6dc54acc44f3d0003fbebff97">countSubReconciliations</a> ()</td></tr>
<tr class="separator:a3fa978c6dc54acc44f3d0003fbebff97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1e86a428bb881669ada1e4cf4a0ba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a2c1e86a428bb881669ada1e4cf4a0ba8">countSubReconciliationsFinishVertex</a> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;baseArgs)</td></tr>
<tr class="separator:a2c1e86a428bb881669ada1e4cf4a0ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9e0c0cc6ca3d76fbdd41276757d4ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a6c9e0c0cc6ca3d76fbdd41276757d4ec">computeSupport</a> (double epsilon)</td></tr>
<tr class="separator:a6c9e0c0cc6ca3d76fbdd41276757d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b55a32ef32a88ae8d32bccbdd6bb56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a57b55a32ef32a88ae8d32bccbdd6bb56">computeSupportDiscoverVertex</a> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;baseArgs)</td></tr>
<tr class="separator:a57b55a32ef32a88ae8d32bccbdd6bb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c5e9309964dd1755f50fe61cf5f261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa7c5e9309964dd1755f50fe61cf5f261">computeR</a> (MyGraph::Vertex z)</td></tr>
<tr class="separator:aa7c5e9309964dd1755f50fe61cf5f261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bed7723d915814ee1271e6e0e76dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a50bed7723d915814ee1271e6e0e76dfa">generateMergedSupport</a> (double epsilon)</td></tr>
<tr class="separator:a50bed7723d915814ee1271e6e0e76dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0205e198131e9cf702a5646090dcef1"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; MyGraph::Vertex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa0205e198131e9cf702a5646090dcef1">createEventDescriptorMap</a> ()</td></tr>
<tr class="separator:aa0205e198131e9cf702a5646090dcef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6912bff9387b9ee1b6e1641d90038516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a6912bff9387b9ee1b6e1641d90038516">weightSupport</a> (double epsilon)</td></tr>
<tr class="separator:a6912bff9387b9ee1b6e1641d90038516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba2c67b31bf45d9663b08087c8a31aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aaba2c67b31bf45d9663b08087c8a31aa">removeNoncanonicalFinishVertex</a> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;baseArgs)</td></tr>
<tr class="separator:aaba2c67b31bf45d9663b08087c8a31aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaefb90c0f05ea96990ad6534b2f1e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#adaefb90c0f05ea96990ad6534b2f1e1d">removeNoncanonicalVertices</a> ()</td></tr>
<tr class="separator:adaefb90c0f05ea96990ad6534b2f1e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a6c32ea24e981b1c8310da4d0ceef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a15a6c32ea24e981b1c8310da4d0ceef9">bestScoreFinishVertex</a> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;baseArgs)</td></tr>
<tr class="separator:a15a6c32ea24e981b1c8310da4d0ceef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ad135d8b9515da11a9411d3764fc62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a31ad135d8b9515da11a9411d3764fc62">printDiscoverVertex</a> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args)</td></tr>
<tr class="separator:a31ad135d8b9515da11a9411d3764fc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da3d6563d5bcb10927ae3f07699021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ab5da3d6563d5bcb10927ae3f07699021">countTLsDiscoverVertex</a> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args)</td></tr>
<tr class="separator:ab5da3d6563d5bcb10927ae3f07699021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e35845bb6f8ad1966f339a316acb75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a86e35845bb6f8ad1966f339a316acb75">traverseAllReconciliations</a> (<a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args, bool(DTLGraph::*handleReconPtr)(int, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;))</td></tr>
<tr class="separator:a86e35845bb6f8ad1966f339a316acb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487164629a2a169a181b2e50079d4f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a2487164629a2a169a181b2e50079d4f5">printHandleRecon</a> (int reconNumber, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;recon, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;baseArgs)</td></tr>
<tr class="separator:a2487164629a2a169a181b2e50079d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb146d2fae316b19b6264f83180cc6a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#acb146d2fae316b19b6264f83180cc6a7">timeConsistentHandleRecon</a> (int reconNumber, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;recon, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;baseArgs)</td></tr>
<tr class="separator:acb146d2fae316b19b6264f83180cc6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048af4b321587a97e396175611704a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a048af4b321587a97e396175611704a73">getAllTransfers</a> (vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;recon, vector&lt; MyGraph::Vertex &gt; &amp;transferFrom, vector&lt; MyGraph::Vertex &gt; &amp;transferTo, vector&lt; vector&lt; int &gt; &gt; &amp;transfersForGene)</td></tr>
<tr class="separator:a048af4b321587a97e396175611704a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26e8c36a0919cdd42a010ddb0a8441"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a2e26e8c36a0919cdd42a010ddb0a8441">isTimeConsistent</a> (vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;recon)</td></tr>
<tr class="separator:a2e26e8c36a0919cdd42a010ddb0a8441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e30b502680ed41d8e59d92e744a2a65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a3e30b502680ed41d8e59d92e744a2a65">getSpeciesParentId</a> (MyGraph::Vertex z)</td></tr>
<tr class="separator:a3e30b502680ed41d8e59d92e744a2a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986a4f2b29590a133f79f24f9d05cb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#af986a4f2b29590a133f79f24f9d05cb3">getFatherXId</a> (MyGraph::Vertex event)</td></tr>
<tr class="separator:af986a4f2b29590a133f79f24f9d05cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027401026f507f98a00b9e47c926b741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a027401026f507f98a00b9e47c926b741">validEvent</a> (MyGraph::Vertex event, MyGraph::Vertex eventSon)</td></tr>
<tr class="separator:a027401026f507f98a00b9e47c926b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef64cb0b45d82e727d9bf7b9cece6281"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aef64cb0b45d82e727d9bf7b9cece6281">validRecNumber</a> (MyGraph::Vertex event, MyGraph::Vertex eventSon1, MyGraph::Vertex eventSon2)</td></tr>
<tr class="separator:aef64cb0b45d82e727d9bf7b9cece6281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c37132088844aebe70d6fca8485942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa1c37132088844aebe70d6fca8485942">resetVisits</a> ()</td></tr>
<tr class="separator:aa1c37132088844aebe70d6fca8485942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dcdfc99863757d0ea73869fb479a0a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ae6dcdfc99863757d0ea73869fb479a0a">mappingFromIds</a> (int id_u, int id_x, double cost)</td></tr>
<tr class="separator:ae6dcdfc99863757d0ea73869fb479a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5d3475e79d4aab5aa7bff6ddefcc46"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a1f5d3475e79d4aab5aa7bff6ddefcc46">mappingFromIds</a> (int id_u, int id_x, double cost, int d, int t, int l)</td></tr>
<tr class="separator:a1f5d3475e79d4aab5aa7bff6ddefcc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460ed5987fe3b5f5e17c561acabc31b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a460ed5987fe3b5f5e17c561acabc31b5">scoreReconciliation</a> (vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation)</td></tr>
<tr class="separator:a460ed5987fe3b5f5e17c561acabc31b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297a7229df349404fcf2ca33cb039fd8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a297a7229df349404fcf2ca33cb039fd8">chooseRandomSupport</a> (vector&lt; double &gt; &amp;supports)</td></tr>
<tr class="separator:a297a7229df349404fcf2ca33cb039fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad8e1af19773ecf096b199ba0a4de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a47ad8e1af19773ecf096b199ba0a4de3">backtrack</a> (MyGraph::Vertex vertex, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, bool random, double scoreMod)</td></tr>
<tr class="separator:a47ad8e1af19773ecf096b199ba0a4de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6ccf68b7bd5314e315332447d7ea81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aea6ccf68b7bd5314e315332447d7ea81">backtrackEvents</a> (MyGraph::Vertex vertex, MyGraph::Vertex mappingVertex, MyGraph::adjacency_vertex_range_t eventSons, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, bool random, double scoreMod)</td></tr>
<tr class="separator:aea6ccf68b7bd5314e315332447d7ea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e33e7cc27b222058de6609f3d51f659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a2e33e7cc27b222058de6609f3d51f659">backtrackEvents</a> (MyGraph::Vertex vertex, MyGraph::Vertex mappingVertex1, MyGraph::Vertex mappingVertex2, MyGraph::adjacency_vertex_range_t eventSons1, MyGraph::adjacency_vertex_range_t eventSons2, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, bool random, double scoreMod)</td></tr>
<tr class="separator:a2e33e7cc27b222058de6609f3d51f659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd7d9fdde09c7022846e499956d5c1"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a65dd7d9fdde09c7022846e499956d5c1">printReconciliationAux</a> (vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, map&lt; string, double &gt; &amp;eventSupports)</td></tr>
<tr class="separator:a65dd7d9fdde09c7022846e499956d5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58909f2d8276b2132bd1de47055dffe2"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a58909f2d8276b2132bd1de47055dffe2">orthologyOutputAux</a> (int idU, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, vector&lt; pair&lt; int, int &gt; &gt; &amp;orthologs)</td></tr>
<tr class="separator:a58909f2d8276b2132bd1de47055dffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745cd0d2e5f8507e051723eaaf9878ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a745cd0d2e5f8507e051723eaaf9878ec">getSpeciesDates</a> (MySpeciesNode *node, vector&lt; double &gt; &amp;startDates, vector&lt; double &gt; &amp;endDates)</td></tr>
<tr class="separator:a745cd0d2e5f8507e051723eaaf9878ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e27d6ad379298f6349b94b67bc603"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ab98e27d6ad379298f6349b94b67bc603">getChildIdx</a> (int idU, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, size_t reconciliationIdx)</td></tr>
<tr class="separator:ab98e27d6ad379298f6349b94b67bc603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9bed72d25402a0513884fd7d288c20"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a8c9bed72d25402a0513884fd7d288c20">makeIntervals</a> (int idU, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, vector&lt; double &gt; &amp;speciesStartDates, vector&lt; double &gt; &amp;speciesEndDates, map&lt; string, double &gt; &amp;eventEndDates, size_t reconciliationIdx=0, double parentStartDate=-1, string fatherEvent=&quot;ROOT&quot;, int prevRpo=-1, int seqNum=0)</td></tr>
<tr class="separator:a8c9bed72d25402a0513884fd7d288c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803be0f9b06289e704e4e22cbb498402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a803be0f9b06289e704e4e22cbb498402">printEvents</a> (int idU, vector&lt; int &gt; &amp;cladeToPOrd, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, vector&lt; double &gt; &amp;speciesEndDates, map&lt; string, double &gt; &amp;eventDates, vector&lt; vector&lt; string &gt; &gt; &amp;eventsByIdU, vector&lt; string &gt; &amp;losses, size_t reconciliationIdx=0, int fatherX=-1, string fatherEvent=&quot;ROOT&quot;, string prevRealX=&quot;ROOT&quot;, string prevRealFatherX=&quot;ROOT&quot;)</td></tr>
<tr class="separator:a803be0f9b06289e704e4e22cbb498402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb273964e1088e6c59eeed001bc40e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcb273964e1088e6c59eeed001bc40e7"></a>
vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSylvxReconciliation</b> (vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation)</td></tr>
<tr class="separator:abcb273964e1088e6c59eeed001bc40e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2882f75ede87de3d1416b41722505f74"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a2882f75ede87de3d1416b41722505f74">getStringId</a> (int idX)</td></tr>
<tr class="separator:a2882f75ede87de3d1416b41722505f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa95f61ccbb44e58fdb00fb62560744"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#adaa95f61ccbb44e58fdb00fb62560744">getSibling</a> (int idX, int sonX, bool realX)</td></tr>
<tr class="separator:adaa95f61ccbb44e58fdb00fb62560744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadaff68607077936ad59cb66684e22fd"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aadaff68607077936ad59cb66684e22fd">getEventString</a> (int idU, int z, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation, int idUl, int idUr, map&lt; string, double &gt; &amp;eventSupports)</td></tr>
<tr class="separator:aadaff68607077936ad59cb66684e22fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac92b7a86c586a4d03da58839422f302"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aac92b7a86c586a4d03da58839422f302">depthFirstOrderIncrement</a> (<a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;decision)</td></tr>
<tr class="separator:aac92b7a86c586a4d03da58839422f302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2f6c1db0c19e20eb8dd8146da6391b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea2f6c1db0c19e20eb8dd8146da6391b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>combineEventLists</b> (MyGraph::Vertex z, MyGraph::Vertex son1, MyGraph::Vertex son2)</td></tr>
<tr class="separator:aea2f6c1db0c19e20eb8dd8146da6391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe62c1da225ff810b3c45283fe5220"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcbe62c1da225ff810b3c45283fe5220"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>allReconsFinishVertex</b> (MyGraph::Vertex z, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;args)</td></tr>
<tr class="separator:adcbe62c1da225ff810b3c45283fe5220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d457692048f25688903fbbb0703e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa5d457692048f25688903fbbb0703e51">printDecisionTree</a> (<a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;decision, int depth=0)</td></tr>
<tr class="separator:aa5d457692048f25688903fbbb0703e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c00dcf3be9f81d12997ced6979b38f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a7c00dcf3be9f81d12997ced6979b38f1">fillRecon</a> (<a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;decision)</td></tr>
<tr class="separator:a7c00dcf3be9f81d12997ced6979b38f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0817c871df2819daf859f130f850497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ad0817c871df2819daf859f130f850497">convertRecon</a> (<a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;decision, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;recon)</td></tr>
<tr class="separator:ad0817c871df2819daf859f130f850497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b483911ebcaf8f1dbf1dab5f5d6257d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a8b483911ebcaf8f1dbf1dab5f5d6257d">checkEventValidity</a> (MyGraph::Vertex z)</td></tr>
<tr class="separator:a8b483911ebcaf8f1dbf1dab5f5d6257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34b7683b04cd9b45efd39d1a98f773"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a9f34b7683b04cd9b45efd39d1a98f773">createNameWithExternalIds</a> (MyGraph::Vertex z, vector&lt; int &gt; &amp;cladeToPOrd)</td></tr>
<tr class="separator:a9f34b7683b04cd9b45efd39d1a98f773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7463ddd084acdba048bc05b46f221c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ae7463ddd084acdba048bc05b46f221c9">getEvents</a> (MyGraph::Vertex z, string &amp;d, string &amp;t, string &amp;l)</td></tr>
<tr class="separator:ae7463ddd084acdba048bc05b46f221c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e8928bd39c5dd396c68f254fe580b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a92e8928bd39c5dd396c68f254fe580b9">hasCycles</a> (int id, vector&lt; vector&lt; int &gt; &gt; &amp;tree, vector&lt; bool &gt; &amp;seenIt)</td></tr>
<tr class="separator:a92e8928bd39c5dd396c68f254fe580b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab913b5718510835d7182ded2198dab"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#adab913b5718510835d7182ded2198dab">getReconciliationFormatHali</a> (<a class="el" href="classMyGeneTree.html">MyGeneTree</a> &amp;geneTree, vector&lt; int &gt; &amp;pOrdToClade, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;reconciliation)</td></tr>
<tr class="separator:adab913b5718510835d7182ded2198dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4014b4f019dbad21fcd314a846362b2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4014b4f019dbad21fcd314a846362b2a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a4014b4f019dbad21fcd314a846362b2a">mOnlyCanonical</a></td></tr>
<tr class="memdesc:a4014b4f019dbad21fcd314a846362b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove non-canonical vertices if true <br /></td></tr>
<tr class="separator:a4014b4f019dbad21fcd314a846362b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dac97975e739ace0e3f0272ac0b04ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dac97975e739ace0e3f0272ac0b04ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a6dac97975e739ace0e3f0272ac0b04ad">mSuboptimal</a></td></tr>
<tr class="memdesc:a6dac97975e739ace0e3f0272ac0b04ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">graph contains suboptimal vertices if true <br /></td></tr>
<tr class="separator:a6dac97975e739ace0e3f0272ac0b04ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85d5cbf2ba9c292bc3e2994b4ee7c2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa85d5cbf2ba9c292bc3e2994b4ee7c2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa85d5cbf2ba9c292bc3e2994b4ee7c2e">mPareto</a></td></tr>
<tr class="memdesc:aa85d5cbf2ba9c292bc3e2994b4ee7c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">use event triplets for suboptimal <br /></td></tr>
<tr class="separator:aa85d5cbf2ba9c292bc3e2994b4ee7c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83dcadbee524586157c95913520bd10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af83dcadbee524586157c95913520bd10"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#af83dcadbee524586157c95913520bd10">mWeighted</a></td></tr>
<tr class="memdesc:af83dcadbee524586157c95913520bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">weight suboptimal support by cost <br /></td></tr>
<tr class="separator:af83dcadbee524586157c95913520bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c88be352db388a957e2beb7dfb7dc36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c88be352db388a957e2beb7dfb7dc36"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a4c88be352db388a957e2beb7dfb7dc36">mEventNumber</a></td></tr>
<tr class="memdesc:a4c88be352db388a957e2beb7dfb7dc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">counter for numbering events <br /></td></tr>
<tr class="separator:a4c88be352db388a957e2beb7dfb7dc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa369af3fec0a7617f3acc3ae1e692426"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa369af3fec0a7617f3acc3ae1e692426"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa369af3fec0a7617f3acc3ae1e692426">mScoredProblem</a></td></tr>
<tr class="memdesc:aa369af3fec0a7617f3acc3ae1e692426"><td class="mdescLeft">&#160;</td><td class="mdescRight">which problem was scored in vertices <br /></td></tr>
<tr class="separator:aa369af3fec0a7617f3acc3ae1e692426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ab71885f9b12fc16cf3033e766106"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d4ab71885f9b12fc16cf3033e766106"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a0d4ab71885f9b12fc16cf3033e766106">mMaxIdU</a></td></tr>
<tr class="memdesc:a0d4ab71885f9b12fc16cf3033e766106"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum idU value <br /></td></tr>
<tr class="separator:a0d4ab71885f9b12fc16cf3033e766106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3adead4f92275012097e2ec13277b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c3adead4f92275012097e2ec13277b7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a8c3adead4f92275012097e2ec13277b7">mProblemScore</a></td></tr>
<tr class="memdesc:a8c3adead4f92275012097e2ec13277b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">median score for current problem (mScoredProblem) <br /></td></tr>
<tr class="separator:a8c3adead4f92275012097e2ec13277b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a7dbb57683f68e8786913a663c73f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a7dbb57683f68e8786913a663c73f8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a25a7dbb57683f68e8786913a663c73f8">mNumberSolutions</a></td></tr>
<tr class="memdesc:a25a7dbb57683f68e8786913a663c73f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of solutions (traversals of graph) <br /></td></tr>
<tr class="separator:a25a7dbb57683f68e8786913a663c73f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21468c01722f944fd6df3ebdbab5f606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21468c01722f944fd6df3ebdbab5f606"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a21468c01722f944fd6df3ebdbab5f606">mWeightedNumberSolutions</a></td></tr>
<tr class="memdesc:a21468c01722f944fd6df3ebdbab5f606"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of solutions with weights <br /></td></tr>
<tr class="separator:a21468c01722f944fd6df3ebdbab5f606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11450dd076cef1f9fc6fde5d1550ed3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11450dd076cef1f9fc6fde5d1550ed3f"></a>
<a class="el" href="classMySpeciesTree.html">MySpeciesTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a11450dd076cef1f9fc6fde5d1550ed3f">mSpeciesTree</a></td></tr>
<tr class="memdesc:a11450dd076cef1f9fc6fde5d1550ed3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">species tree used to calculate matrix <br /></td></tr>
<tr class="separator:a11450dd076cef1f9fc6fde5d1550ed3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbdb4f2d4e23ca04e08e1382c2b9b78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fbdb4f2d4e23ca04e08e1382c2b9b78"></a>
<a class="el" href="classCladesAndTripartitions.html">CladesAndTripartitions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a7fbdb4f2d4e23ca04e08e1382c2b9b78">mCladesTrips</a></td></tr>
<tr class="memdesc:a7fbdb4f2d4e23ca04e08e1382c2b9b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">clades and tripartitions used in matrix calculation <br /></td></tr>
<tr class="separator:a7fbdb4f2d4e23ca04e08e1382c2b9b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5b0fe2de03906095d097df6de0ccc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4a5b0fe2de03906095d097df6de0ccc"></a>
<a class="el" href="classDTLGraph.html#a9d551ab4081bb68aba57bb315246a7a6">MyGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#ad4a5b0fe2de03906095d097df6de0ccc">mGraph</a></td></tr>
<tr class="memdesc:ad4a5b0fe2de03906095d097df6de0ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">the graph <br /></td></tr>
<tr class="separator:ad4a5b0fe2de03906095d097df6de0ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3bf09698b7b575ddc3b88089571215"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe3bf09698b7b575ddc3b88089571215"></a>
vector&lt; MyGraph::Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#abe3bf09698b7b575ddc3b88089571215">mRootVertices</a></td></tr>
<tr class="memdesc:abe3bf09698b7b575ddc3b88089571215"><td class="mdescLeft">&#160;</td><td class="mdescRight">graph is forest <br /></td></tr>
<tr class="separator:abe3bf09698b7b575ddc3b88089571215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf5e10bbf6cc132a94bfcb3b4e13d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf5e10bbf6cc132a94bfcb3b4e13d81"></a>
map&lt; string, MyGraph::Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#acaf5e10bbf6cc132a94bfcb3b4e13d81">mVertexMap</a></td></tr>
<tr class="memdesc:acaf5e10bbf6cc132a94bfcb3b4e13d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertex name -&gt; vertex <br /></td></tr>
<tr class="separator:acaf5e10bbf6cc132a94bfcb3b4e13d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa004be18e48c3c5a1e3db2cdf2f87011"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#aa004be18e48c3c5a1e3db2cdf2f87011">SCORE_DIFF</a> = 0.00000000001</td></tr>
<tr class="memdesc:aa004be18e48c3c5a1e3db2cdf2f87011"><td class="mdescLeft">&#160;</td><td class="mdescRight">at which they are considered different.  <a href="#aa004be18e48c3c5a1e3db2cdf2f87011">More...</a><br /></td></tr>
<tr class="separator:aa004be18e48c3c5a1e3db2cdf2f87011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921386ab3704265486bbb66806417f77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a921386ab3704265486bbb66806417f77"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDTLGraph.html#a921386ab3704265486bbb66806417f77">NAME_PRECISION</a> = 12</td></tr>
<tr class="memdesc:a921386ab3704265486bbb66806417f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precision of costs in vertex names. <br /></td></tr>
<tr class="separator:a921386ab3704265486bbb66806417f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classDTLGraph.html">DTLGraph</a> represents all possible solutions to a most parsimonious reconciliation. There are two types of vertices: pairs and events. A pair vertex contains a clade (subtree of genes) and a species node which are reconciled. Additionally, a pair (mapping) vertex contains a cost for suboptimal reconciliations, which can contain the same clade/species node reconciliations are different costs. Event vertices represent the possible DTL (duplications, transfer, loss) events that can occur from a vertex pair. A traversal following all vertex pairs and a single event vertex from each node will result in a single solution. The countReconciliationNumberAndCheck function calculates the number of solutions and finds the number of solutions each event vertex is in. The getBestScore calculates a graph score.</p>
<p>A <a class="el" href="classDTLGraph.html">DTLGraph</a> is a forest (mRootVertices). Each root represents a differnt mapping from the species tree to the root of the gene tree.</p>
<p>The <a class="el" href="classDTLGraph.html">DTLGraph</a> has three types of public functions:</p>
<ol type="1">
<li><a class="el" href="classGraph.html">Graph</a> creation: addPairVertex, addEventVertex, addRoot, getPairVertexByName.</li>
<li>Property calculation: countReconciilationNumberAndCheck and getBestScore.</li>
<li>Property retreival: getScoredReconciliation, getVertexIdentfiers, and getEventCounts.</li>
</ol>
<p>For debugging, there is also the printGraph function.</p>
<p>Finally, the getAlphas returns a represenation of all solutions, but is no longer supported and should be redone if it is to be used.</p>
<p><a class="el" href="classDTLGraph.html">DTLGraph</a> is modeled on the BOOST graph library, and therefore uses generic vertices with a vertex property structure attached to each node. The BOOST library functions are restricted to the <a class="el" href="classGraph.html">Graph</a> class, which should help if the <a class="el" href="classGraph.html">Graph</a> class needs to be rewritten without BOOST.</p>
<p>As many functions as possible have been written as graph traversal functions to simplify the code. The functions depthFirstTraversal and breadthFirstTraversal take two functions pointers as input, which are run pre-order and post-order at each vertex. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a59d412dd5aba9801006f2fc402bdbf69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DTLGraph::DTLGraph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suboptimal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pareto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMySpeciesTree.html">MySpeciesTree</a> *&#160;</td>
          <td class="paramname"><em>speciesTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCladesAndTripartitions.html">CladesAndTripartitions</a> *&#160;</td>
          <td class="paramname"><em>cladesTrips</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DTL <a class="el" href="classGraph.html">Graph</a> Constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suboptimal</td><td><a class="el" href="classGraph.html">Graph</a> is suboptimal if true. </td></tr>
    <tr><td class="paramname">pareto</td><td>use event triplets </td></tr>
    <tr><td class="paramname">speciesTree</td><td>Species tree used to construct matrix. </td></tr>
    <tr><td class="paramname">cladesTrips</td><td>Clades/tripartions for the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2835ea04e5f5113f31db428978ea5721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DTLGraph::MyGraph::Vertex DTLGraph::addEventVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an event vertex and add an edge from z to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>connecting vertex </td></tr>
    <tr><td class="paramname">event</td><td>type of event for the new vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28266600aeb31b14fec38d8e7f74bd19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::addPairVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>eventVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex &amp;&#160;</td>
          <td class="paramname"><em>pairVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an edge between eventVertex and the vertex identified by by id_u, id_x, and cost.</p>
<p>A vertex is created if it doesn't exist, using id_u, id_x, and cost as identifiers.</p>
<dl class="section return"><dt>Returns</dt><dd>true if it is novel (added) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventVertex</td><td>the parent vertex of the new vertex </td></tr>
    <tr><td class="paramname">id_u</td><td>clade identifier </td></tr>
    <tr><td class="paramname">id_x</td><td>species node identifier </td></tr>
    <tr><td class="paramname">cost</td><td>node cost </td></tr>
    <tr><td class="paramname">pairVertex</td><td>returns the vertex identifed by id_u, id_x, and cost - either newly created or found in the current set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae22e846b18be0dbd538a3779115859a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::addPairVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>eventVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex &amp;&#160;</td>
          <td class="paramname"><em>pairVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an edge between eventVertex and the vertex identified by by id_u, id_x, cost, and d, t, and l counts.</p>
<p>A vertex is created if it doesn't exist, using id_u, id_x, cost, d, t, an l as identifiers.</p>
<dl class="section return"><dt>Returns</dt><dd>true if it is novel (added) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventVertex</td><td>the parent vertex of the new vertex </td></tr>
    <tr><td class="paramname">id_u</td><td>clade identifier </td></tr>
    <tr><td class="paramname">id_x</td><td>species node identifier </td></tr>
    <tr><td class="paramname">cost</td><td>node cost </td></tr>
    <tr><td class="paramname">d</td><td>duplication counts </td></tr>
    <tr><td class="paramname">t</td><td>transfer counts </td></tr>
    <tr><td class="paramname">l</td><td>loss counts </td></tr>
    <tr><td class="paramname">pairVertex</td><td>returns the vertex - either newly created or found in the current set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6242513734d9c65d80da9e042bd03df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DTLGraph::MyGraph::Vertex DTLGraph::addRoot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a root vertex and return it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new</td><td>vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_u</td><td>clade identifier </td></tr>
    <tr><td class="paramname">id_x</td><td>species node identifier </td></tr>
    <tr><td class="paramname">cost</td><td>node cost </td></tr>
    <tr><td class="paramname">d</td><td>duplication counts </td></tr>
    <tr><td class="paramname">t</td><td>transfer counts </td></tr>
    <tr><td class="paramname">l</td><td>loss counts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47ad8e1af19773ecf096b199ba0a4de3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::backtrack </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>random</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scoreMod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursive function to implment getScoreReconciliation.</p>
<p>Fill and return a vector with nodes from a single reconciliation, corresponding to the best score calculated. The tree is created by choosing just one child for each mapping node. The choice is either the child corresponding to the currently score problem or a random child.</p>
<p>This function handles the mapping nodes and sets up the call to the backtrack through events.</p>
<p>Note: this function recursive, but does not use the graph traversal functionality since it is selectively visiting vertices, and not all vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>current event vertex in the recursion </td></tr>
    <tr><td class="paramname">reconciliation</td><td>Reconciliation being built </td></tr>
    <tr><td class="paramname">random</td><td>Build a random reconciltaion if true. </td></tr>
    <tr><td class="paramname">scoreMod</td><td>Value to add to score for certain problems. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea6ccf68b7bd5314e315332447d7ea81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::backtrackEvents </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>parentVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>mappingVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::adjacency_vertex_range_t&#160;</td>
          <td class="paramname"><em>eventSons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>random</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scoreMod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backtrack through events for vertices with one son.</p>
<p>Follow sons whose score matches the best score. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentVertex</td><td>parent event vertex </td></tr>
    <tr><td class="paramname">mappingVertex</td><td>parent mapping vertex </td></tr>
    <tr><td class="paramname">eventSons</td><td>current event verticies in the recursion </td></tr>
    <tr><td class="paramname">reconciliation</td><td>Reconciliation being built </td></tr>
    <tr><td class="paramname">random</td><td>build a random reconciltaion if true </td></tr>
    <tr><td class="paramname">scoreMod</td><td>Value to add to score for certain problems. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e33e7cc27b222058de6609f3d51f659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::backtrackEvents </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>parentVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>mappingVertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>mappingVertex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::adjacency_vertex_range_t&#160;</td>
          <td class="paramname"><em>eventSons1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::adjacency_vertex_range_t&#160;</td>
          <td class="paramname"><em>eventSons2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>random</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scoreMod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backtrack through events for vertices with one son.</p>
<p>Follow sons whose score matches the best score. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentVertex</td><td>parent mapping vertex </td></tr>
    <tr><td class="paramname">mappingVertex1</td><td>parent mapping vertex 1 </td></tr>
    <tr><td class="paramname">mappingVertex2</td><td>parent mapping vertex 2 </td></tr>
    <tr><td class="paramname">eventSons1</td><td>current event verticies in the recursion from son1 </td></tr>
    <tr><td class="paramname">eventSons2</td><td>current event verticies in the recursion from son2 </td></tr>
    <tr><td class="paramname">reconciliation</td><td>Reconciliation being built </td></tr>
    <tr><td class="paramname">random</td><td>built a random reconciltaion </td></tr>
    <tr><td class="paramname">scoreMod</td><td>Value to add to score for certain problems. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15a6c32ea24e981b1c8310da4d0ceef9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::bestScoreFinishVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traversal function for calculating the median score (score property).</p>
<p>For event nodes, sum the support with the children scores (summing sons differently depending on the problem type). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">baseArgs</td><td>cast to <a class="el" href="classDTLGraph_1_1BestScoreArgs.html">BestScoreArgs</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68ec25cce8e2c4b3c2e4a6a0867cde2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::breadthFirstTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>discoverVertexPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>finishVertexPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Breadth first traversal from each root.</p>
<p>The given functions are called at each vertex (if not null). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>structure containing traversal specific variables </td></tr>
    <tr><td class="paramname">discoverVertexPtr</td><td>function called before visiting children </td></tr>
    <tr><td class="paramname">finishVertexPtr</td><td>function called after visiting children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade0a6158981a93bda1fafe890986e752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::breadthFirstTraversalAux </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>discoverVertexPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>finishVertexPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursive part of breadthFirstTraversal.</p>
<p>A vertex is visited only after all of it's parents have been visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">isRoot</td><td>vertex is visited as root </td></tr>
    <tr><td class="paramname">args</td><td>structure containing traversal specific variables </td></tr>
    <tr><td class="paramname">discoverVertexPtr</td><td>function called before visiting children </td></tr>
    <tr><td class="paramname">finishVertexPtr</td><td>function called after visiting children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b483911ebcaf8f1dbf1dab5f5d6257d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::checkEventValidity </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the given event vertex is canonical for the current reconciliation.</p>
<p>If non-canoical nodes were removed, this might not do anything unless the more complex criteria are used.</p>
<p>The visits vertex property is used to choose mapping sons if the event has two sons.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the event is valid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>vertex to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01bbc12ff0c7009dcdf6924043aaa32e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DTLGraph::checkTimeConsistencies </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkAll</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check time consistencies of all reconciliations.</p>
<dl class="section return"><dt>Returns</dt><dd>0 for inconsistent, 1 for consistent, 2 for unknown </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>maximum number of reconciliations to check </td></tr>
    <tr><td class="paramname">checkAll</td><td>check all, else until found consistent or limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a297a7229df349404fcf2ca33cb039fd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t DTLGraph::chooseRandomSupport </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>supports</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Choose a support randomly, weighting the supports.</p>
<dl class="section return"><dt>Returns</dt><dd>weighted random number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supports</td><td>list of supports </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7c5e9309964dd1755f50fe61cf5f261"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::computeR </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute r values for grand children.</p>
<p>Used by computeSupportDiscoverVertex to calculate valid reconciliations for the grandchilren of z. The r value is the recNumber for valid grandchildren if the z has one child. If z has two children, r is the product of valid cousins (calculated in validRecNumber). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>compute r for event grandsons of this vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c9e0c0cc6ca3d76fbdd41276757d4ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::computeSupport </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Label each vertex with the number of reconciliations it is in for each root (support or supportVector property).</p>
<p>The support for each vertex for the subgraph of each root is stored in supportVector, indexed by the order of the root vertices.</p>
<p>The computeSupportDiscoverVertex function is used in a traversal to do the calculation once the root sons are intialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>Epsilon of costs (used if suboptimal) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57b55a32ef32a88ae8d32bccbdd6bb56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::computeSupportDiscoverVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traversal function for computeSupport.</p>
<p>Calculates support for event nodes. Each event vertice's reconciliations are assigned proportionally to the grand children. For weighted support (mWeighted), the support for each root's subgraph is calculated separately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">baseArgs</td><td>not used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0817c871df2819daf859f130f850497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::convertRecon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>decision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>recon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a decision tree into a reconcilation structure.</p>
<p>A reconciliation structure is list of vertices for each clade. Each vertex list is ordered by the traversal order of the graph, which keeps species parent nodes before the children.</p>
<dl class="section return"><dt>Returns</dt><dd>True if reconcialition is valid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decision</td><td>current decision node in recursion </td></tr>
    <tr><td class="paramname">recon</td><td>reconcilation structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30691e1ecd335aaaaefe30a1bfe4130b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::countReconciliationNumberAndCheck </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyCanonical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>weighted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Label the graph with the number of reconciliations each vertex is part of.</p>
<p>If mOnlyCanonical is true, remove any vertices not in any canonical reconciliation (recNumber=0).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the number of solutions is finite. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>Epsilon, for suboptimal graphs. </td></tr>
    <tr><td class="paramname">onlyCanonical</td><td>Remove non-canonical vertices </td></tr>
    <tr><td class="paramname">verbose</td><td>print debugging information </td></tr>
    <tr><td class="paramname">weighted</td><td>weight the support for each vertex (suboptimal) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fa978c6dc54acc44f3d0003fbebff97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DTLGraph::countSubReconciliations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find number of reconciliations in sub-graph rooted at each vertex (recNumber property).</p>
<p>Traverse the graph and label each vertex with the number of reconciliations possible for the sub-graph at that vertex by multiplying the reconciliations of children for event vertices and summing the reconciliations of children for mapping vertices. Put the value in recNumber.</p>
<dl class="section return"><dt>Returns</dt><dd>number of reconciliations for the entire graph </dd></dl>

</div>
</div>
<a class="anchor" id="a2c1e86a428bb881669ada1e4cf4a0ba8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::countSubReconciliationsFinishVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traversal function for countSubReconciliations</p>
<p>Leaves have a single reconciliation. Mapping nodes sum sons. Event nodes with one children sum valid grandchilren. Event nodes with two children sum all combinations of valid cousins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">baseArgs</td><td>not used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac913b28e5f28d1840b9eec21881b29e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DTLGraph::countTLs </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Average number of TLs per reconciliation.</p>
<dl class="section return"><dt>Returns</dt><dd>The support for TLs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>frequency of TL (among non-C events) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5da3d6563d5bcb10927ae3f07699021"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::countTLsDiscoverVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traversal function for countTLs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">baseArgs</td><td>cast to <a class="el" href="classDTLGraph_1_1CountTLsArgs.html">CountTLsArgs</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0205e198131e9cf702a5646090dcef1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; DTLGraph::MyGraph::Vertex &gt; &gt; DTLGraph::createEventDescriptorMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create string identifiers for events and map them to the events.</p>
<p>Generate a string identifer for each event of the form u,x|u1,x1;u2,x2 and insert event into a map </p>

</div>
</div>
<a class="anchor" id="a9f34b7683b04cd9b45efd39d1a98f773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::createNameWithExternalIds </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cladeToPOrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a name using external ids (clade post order and species real post order).</p>
<p>The name is of the format "(idU,idX,cost)".</p>
<dl class="section return"><dt>Returns</dt><dd>name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>vertex </td></tr>
    <tr><td class="paramname">cladeToPOrd</td><td>mapping for clade ids </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58e47a0503029779208530f73b1ee010"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DTLGraph::MyGraph::Vertex DTLGraph::createPairVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create vertex using id_u, id_x, and cost as the vertex identifiers and add it to vertex map.</p>
<dl class="section return"><dt>Returns</dt><dd>new vertex </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_u</td><td>clade identifier </td></tr>
    <tr><td class="paramname">id_x</td><td>species node identifier </td></tr>
    <tr><td class="paramname">cost</td><td>node cost </td></tr>
    <tr><td class="paramname">d</td><td>duplication counts </td></tr>
    <tr><td class="paramname">t</td><td>transfer counts </td></tr>
    <tr><td class="paramname">l</td><td>loss counts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac92b7a86c586a4d03da58839422f302"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::depthFirstOrderIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>decision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Visits nodes of a decision tree in depth first order, incrementing the visits property.</p>
<p>The first node is visited. If it can be incremented, it is marked as changed and the recursion ends.</p>
<p>If not, the node is reset, marked as changed, and the next node in DFS is visted, repeating the procedure.</p>
<p>All combinations have been visited when the first call returns true (the root reset).</p>
<dl class="section return"><dt>Returns</dt><dd>True if this vertex was reset. </dd></dl>

</div>
</div>
<a class="anchor" id="ab980c487b7c269f5f6e714b5e7852ec5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::depthFirstTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>discoverVertexPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>finishVertexPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Depth first traversal from each root.</p>
<p>The given functions are called at each vertex (if not null). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>structure containing traversal specific variables </td></tr>
    <tr><td class="paramname">discoverVertexPtr</td><td>function called before visiting children </td></tr>
    <tr><td class="paramname">finishVertexPtr</td><td>function called after visiting children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af511e62318d075642c95dea1d953c3ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::depthFirstTraversalAux </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>discoverVertexPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(DTLGraph::*)(MyGraph::Vertex, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>finishVertexPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursive part of depthFirstTraversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">args</td><td>structure containing traversal specific variables </td></tr>
    <tr><td class="paramname">discoverVertexPtr</td><td>function called before visiting children </td></tr>
    <tr><td class="paramname">finishVertexPtr</td><td>function called after visiting children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c00dcf3be9f81d12997ced6979b38f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::fillRecon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>decision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traverse the decision tree and fill it with vertices in the current reconciliation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decision</td><td>current decision node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50bed7723d915814ee1271e6e0e76dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::generateMergedSupport </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge support for similar events for suboptimal costs.</p>
<p>For the suboptimal case, event supports (support) must be merged for events with identical parent and children clades and species (u,x), where the costs can be different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>Epsilon of cost range for weighted calculation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a048af4b321587a97e396175611704a73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::getAllTransfers </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>recon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; MyGraph::Vertex &gt; &amp;&#160;</td>
          <td class="paramname"><em>transferFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; MyGraph::Vertex &gt; &amp;&#160;</td>
          <td class="paramname"><em>transferTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfersForGene</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get all transfers and return parallel vectors with their source and target vertices. Also return a vector with all sources (by transferFrom index) from the same gene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recon</td><td>a reconciliation </td></tr>
    <tr><td class="paramname">transferFrom</td><td>transfer sources </td></tr>
    <tr><td class="paramname">transferTo</td><td>transfer targets </td></tr>
    <tr><td class="paramname">transfersForGene</td><td>index for each gene </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf50ab0c5534af0bbc58018be4270cad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DTLGraph::getBestScore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>problem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates reconciliation score (4 types).</p>
<dl class="section return"><dt>Returns</dt><dd>the score </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">problem</td><td>The type of score. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab98e27d6ad379298f6349b94b67bc603"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DTLGraph::getChildIdx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reconciliationIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reconciliationIdx</td><td>current event in reconciliation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7463ddd084acdba048bc05b46f221c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::getEvents </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get events for this vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>vertex </td></tr>
    <tr><td class="paramname">d</td><td>duplication count </td></tr>
    <tr><td class="paramname">t</td><td>transfer count </td></tr>
    <tr><td class="paramname">l</td><td>loss count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadaff68607077936ad59cb66684e22fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::getEventString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idUl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idUr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventSupports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an event string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idU</td><td>current clade </td></tr>
    <tr><td class="paramname">z</td><td>index in reconciliation of current mapping vertex </td></tr>
    <tr><td class="paramname">reconciliation</td><td>list of vertices, by clade in the reconcilation </td></tr>
    <tr><td class="paramname">idUl</td><td>current left clade child </td></tr>
    <tr><td class="paramname">idUr</td><td>current right clade child </td></tr>
    <tr><td class="paramname">eventSupports</td><td>supports to use if this is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa66350deee56392e7450333be41b2ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::getEventSupports </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventSupports</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get event supports as a fracation of the number of solutions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventSupports</td><td>event supports to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af986a4f2b29590a133f79f24f9d05cb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DTLGraph::getFatherXId </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given event vertex, get the id of its parent mapping vertex.</p>
<dl class="section return"><dt>Returns</dt><dd>id of parent </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>an event vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51906543c06da66e1791758a8f5144a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DTLGraph::getNumberSolutions </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>weighted</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of solutions for graph. </p>

</div>
</div>
<a class="anchor" id="adab913b5718510835d7182ded2198dab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::getReconciliationFormatHali </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMyGeneTree.html">MyGeneTree</a> &amp;&#160;</td>
          <td class="paramname"><em>geneTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pOrdToClade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reconciliation in Hali's format. DEPRECATED </p>

</div>
</div>
<a class="anchor" id="a7d1c65174bb829583704140da3db6dc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::getScoredReconciliation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cladeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>random</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reconciliation corresponding to the best score.</p>
<p>The graph is traversed, following only vertices corresponding to the best score.</p>
<dl class="section return"><dt>Returns</dt><dd>False if the score is infinite. </dd></dl>

</div>
</div>
<a class="anchor" id="adaa95f61ccbb44e58fdb00fb62560744"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DTLGraph::getSibling </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sonX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>realX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the given id, search the sons to find the son id and return the other one.</p>
<dl class="section return"><dt>Returns</dt><dd>The sibling of sonX. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idX</td><td>species id </td></tr>
    <tr><td class="paramname">sonX</td><td>kept son species id </td></tr>
    <tr><td class="paramname">realX</td><td>use real ids </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a745cd0d2e5f8507e051723eaaf9878ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DTLGraph::getSpeciesDates </td>
          <td>(</td>
          <td class="paramtype">MySpeciesNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>startDates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>endDates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>species node </td></tr>
    <tr><td class="paramname">startDates</td><td>start date (earliest/highest) </td></tr>
    <tr><td class="paramname">endDates</td><td>end dates for species </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e30b502680ed41d8e59d92e744a2a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DTLGraph::getSpeciesParentId </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the given node, find the species node associated with the vertex (mapping vertex) and return the post order id of that node's parent in the species tree.</p>
<dl class="section return"><dt>Returns</dt><dd>parent id or -1 if no father </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A mapping vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2882f75ede87de3d1416b41722505f74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::getStringId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get leaf name for a node by id or it's post order id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idX</td><td>species postorder id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96cc9a3c914298d7ae264cef0bde1f89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::getVertexIdentfiers </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get vertex properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>the vertex </td></tr>
    <tr><td class="paramname">id_u</td><td>clade id </td></tr>
    <tr><td class="paramname">id_x</td><td>species id </td></tr>
    <tr><td class="paramname">cost</td><td>cost </td></tr>
    <tr><td class="paramname">d</td><td>duplication count </td></tr>
    <tr><td class="paramname">t</td><td>transfer count </td></tr>
    <tr><td class="paramname">l</td><td>loss count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3931b5b64666214f0f3a5be6c2cac87e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::getVertexIdentfiers </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return ids and cost for vertex </p>

</div>
</div>
<a class="anchor" id="a5fd83830e8ff9fb07fa6644f65c38189"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::getVertexName </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return vertex name.</p>
<p>name </p>

</div>
</div>
<a class="anchor" id="a92e8928bd39c5dd396c68f254fe580b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::hasCycles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>seenIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursive function to check for cycles in an id tree.</p>
<p>The given tree is a vector of vector ids, one for each node in the tree, where each node's vector contains a list of children ids. The seenIt vector contains the list of parents of this node. There is a cycle if a parent is visited a second time.</p>
<dl class="section return"><dt>Returns</dt><dd>True if there is a cycle. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>current id in the recursion </td></tr>
    <tr><td class="paramname">tree</td><td>a tree of ids </td></tr>
    <tr><td class="paramname">seenIt</td><td>list of ids seen above this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e26e8c36a0919cdd42a010ddb0a8441"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::isTimeConsistent </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>recon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the reconciliation is consistent (no cycles).</p>
<p>A reconciliation is consistent if there no cycles in the species tree when transfers are considered.</p>
<dl class="section return"><dt>Returns</dt><dd>True if consistent. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recon</td><td>a reconciliation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c9bed72d25402a0513884fd7d288c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::makeIntervals </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>speciesStartDates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>speciesEndDates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventDates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reconciliationIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>parentStartDate</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>parentEvent</em> = <code>&quot;ROOT&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prevRpo</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seqNum</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speciesStartDates</td><td>input species start times </td></tr>
    <tr><td class="paramname">speciesEndDates</td><td>input species end times </td></tr>
    <tr><td class="paramname">eventDates</td><td>output event end times </td></tr>
    <tr><td class="paramname">reconciliationIdx</td><td>current event in reconciliation </td></tr>
    <tr><td class="paramname">parentStartDate</td><td>defaults to -1 for root </td></tr>
    <tr><td class="paramname">parentEvent</td><td>defaults to R for root </td></tr>
    <tr><td class="paramname">prevRpo</td><td>previous species real post order </td></tr>
    <tr><td class="paramname">seqNum</td><td>number of event in current species </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6dcdfc99863757d0ea73869fb479a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::mappingFromIds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates vertex names.</p>
<p>Used in the map from names to vertices to retreive vertices by name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_u</td><td>clade identifier </td></tr>
    <tr><td class="paramname">id_x</td><td>species identifier </td></tr>
    <tr><td class="paramname">cost</td><td>cost for this id_u,id_x pair </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f5d3475e79d4aab5aa7bff6ddefcc46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string DTLGraph::mappingFromIds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates vertex names with event counts.</p>
<p>Used in the map from names to vertices to retreive vertices by name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_u</td><td>clade identifier </td></tr>
    <tr><td class="paramname">id_x</td><td>species identifier </td></tr>
    <tr><td class="paramname">cost</td><td>cost for this id_u,id_x pair </td></tr>
    <tr><td class="paramname">d</td><td>duplication counts </td></tr>
    <tr><td class="paramname">t</td><td>transfer counts </td></tr>
    <tr><td class="paramname">l</td><td>loss counts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af61265536ac61f7cacd3034019ad8bbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::orthologyOutput </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print pairs of orthologous gene ids to a file.</p>
<p>Orthologous gene pairs are those whose least common ancestor map to a speciation event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>base output file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58909f2d8276b2132bd1de47055dffe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; DTLGraph::orthologyOutputAux </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>orthologs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively find orthologous gene pairs.</p>
<dl class="section return"><dt>Returns</dt><dd>List of descedent genes by id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idU</td><td>current gene id </td></tr>
    <tr><td class="paramname">reconciliation</td><td>reconciliation </td></tr>
    <tr><td class="paramname">orthologs</td><td>resulting pairs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cd4fd3dab8fa8dd60dacfd2d0b5e5de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long DTLGraph::printAllReconciliations </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sylvxFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkConsistent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all reconciliations to the given file.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of reconciliations printed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>File name </td></tr>
    <tr><td class="paramname">sylvxFormat</td><td>output in the Sylvx format </td></tr>
    <tr><td class="paramname">checkConsistent</td><td>only print consistent reconciliations </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of reconciliations to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5d457692048f25688903fbbb0703e51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::printDecisionTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1DecisionNode.html">DecisionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>decision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print decision tree.</p>
<p>For debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decision</td><td>current node </td></tr>
    <tr><td class="paramname">depth</td><td>depth of recursion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31ad135d8b9515da11a9411d3764fc62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::printDiscoverVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traversal function for printGraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">baseArgs</td><td>cast to <a class="el" href="classDTLGraph_1_1PrintArgs.html">PrintArgs</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a803be0f9b06289e704e4e22cbb498402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::printEvents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cladeToPOrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>speciesEndDates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventDates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventsByIdU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>losses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reconciliationIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fatherX</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fatherEvent</em> = <code>&quot;ROOT&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>prevRealX</em> = <code>&quot;ROOT&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>prevRealFatherX</em> = <code>&quot;ROOT&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idU</td><td>current gene id </td></tr>
    <tr><td class="paramname">cladeToPOrd</td><td>clade mapping </td></tr>
    <tr><td class="paramname">reconciliation</td><td>the reconciliation </td></tr>
    <tr><td class="paramname">speciesEndDates</td><td>input species end times </td></tr>
    <tr><td class="paramname">eventDates</td><td>output event end times </td></tr>
    <tr><td class="paramname">eventsByIdU</td><td>output strings </td></tr>
    <tr><td class="paramname">losses</td><td>loss strings </td></tr>
    <tr><td class="paramname">reconciliationIdx</td><td>current event in reconciliation </td></tr>
    <tr><td class="paramname">fatherEvent</td><td>defaults to R for root </td></tr>
    <tr><td class="paramname">prevRealX</td><td>previous species id </td></tr>
    <tr><td class="paramname">prevRealFatherX</td><td>previous father species id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85f4daa5c06ca87a8f91b5e584099522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::printGraph </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useInternalIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanGraph</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the edges of the graph (pairs of vertices) with the number of reconciliations each vertex is in (support). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>File name </td></tr>
    <tr><td class="paramname">cleanGraph</td><td>If true, only print canonical vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2487164629a2a169a181b2e50079d4f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::printHandleRecon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reconNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>recon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print all reconcilations function, used with reconciliation traversal.</p>
<dl class="section return"><dt>Returns</dt><dd>True to continue printing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reconNumber</td><td>ordinal of reconciliation in traversal </td></tr>
    <tr><td class="paramname">recon</td><td>a reconciliation </td></tr>
    <tr><td class="paramname">baseArgs</td><td>class containing other arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff9fc9011d848a896928597079b5e2d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::printReconciliation </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>problemStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sylvxFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkConsistent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isConsistent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventSupports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print one or all problem reconciliations to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">problemStr</td><td>which reconciliation: symmetric, asymmetric, random, or all </td></tr>
    <tr><td class="paramname">fileName</td><td>base output file name </td></tr>
    <tr><td class="paramname">sylvxFormat</td><td>use the Sylvx format for the reconciliation </td></tr>
    <tr><td class="paramname">checkConsistent</td><td>check consistency of reconciliation </td></tr>
    <tr><td class="paramname">isConsistent</td><td>returns true if at least one is consistent </td></tr>
    <tr><td class="paramname">eventSupports</td><td>event supports to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65dd7d9fdde09c7022846e499956d5c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; DTLGraph::printReconciliationAux </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventSupports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a string representation of a reconciliation.</p>
<p>Each line of the reconciliation is a clade. Ids are postorder and not internal ids. For clade leaves, the leaf name is given rather than the postorder id.</p>
<p>The input reconciliation are lists of vertices, by clade.</p>
<p>Format: cladeId: [event];...;[event]: cladeSonId1, cladeSonId2 [event] = "speciesId,eventName,[aux]@eventSupport" [aux] = speciesSonId1,speciesSonId2 for S and T events = lost species id for SL events</p>
<dl class="section return"><dt>Returns</dt><dd>A reconciliation as a list of strings. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reconciliation</td><td>list of vertices, by clade in the reconcilation, </td></tr>
    <tr><td class="paramname">eventSupports</td><td>supports to use if this is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dd4992ee1587673528a21be05233ab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::printReconciliationHali </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMyGeneTree.html">MyGeneTree</a> &amp;&#160;</td>
          <td class="paramname"><em>geneTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pOrdToClade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>outDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extensionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>triplets</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reconciliation in Hali's format. DEPRECATED </p>

</div>
</div>
<a class="anchor" id="ac9a95dc61d064b6c91785ef41dc553c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::pruneNonoptimal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all vertices with non-optimal costs. </p>

</div>
</div>
<a class="anchor" id="aaba2c67b31bf45d9663b08087c8a31aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::removeNoncanonicalFinishVertex </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traversal function for removeNoncanonicalVertices</p>
<p>Copy current vertex and it's out edges to the new graph. The baseArgs variable is cast to <a class="el" href="classDTLGraph_1_1RemoveArgs.html">RemoveArgs</a>, which contains the new graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>currently visited vertex </td></tr>
    <tr><td class="paramname">baseArgs</td><td>cast to <a class="el" href="classDTLGraph_1_1RemoveArgs.html">RemoveArgs</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaefb90c0f05ea96990ad6534b2f1e1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::removeNoncanonicalVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove non-canonical vertices.</p>
<p>Find and remove non-canoical vertices. These will be vertices with recNumber=0 if reconciliations were counted with mOnlyCanonical=true.</p>
<p>This removes vertices with no reconciliations because there are no canonical reconciliations. However, non-conical reconciliations will still exist in the graph, especially if some of the more complicated non-canonical conditions are use, e.g. condition7. </p>

</div>
</div>
<a class="anchor" id="aa1c37132088844aebe70d6fca8485942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::resetVisits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>various utility functions </p>

</div>
</div>
<a class="anchor" id="a4e79d62d7706994409932ff97821ccc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::SCORE_EQUAL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score comparison accounting for rounding.</p>
<dl class="section return"><dt>Returns</dt><dd>true if a is equal to b </dd></dl>

</div>
</div>
<a class="anchor" id="abc65049ffb1053d8a0f7759070289eb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::SCORE_GREATER </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score comparison accounting for rounding.</p>
<dl class="section return"><dt>Returns</dt><dd>true if a is greater than b </dd></dl>

</div>
</div>
<a class="anchor" id="a460ed5987fe3b5f5e17c561acabc31b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DTLGraph::scoreReconciliation </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reconciliation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the reconciliation score.</p>
<dl class="section return"><dt>Returns</dt><dd>reconciliation score </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reconciliation</td><td>Reconciliation being built </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb146d2fae316b19b6264f83180cc6a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::timeConsistentHandleRecon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reconNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>recon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All reconciliation traversal function that checks if the current reconciliation is consistent (no cycles).</p>
<p>A reconciliation is consistent if there no cycles in the species tree when transfers are considered.</p>
<dl class="section return"><dt>Returns</dt><dd>True if not consistent or not searching all (true=continue). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reconNumber</td><td>ordinal of reconciliation in traversal </td></tr>
    <tr><td class="paramname">recon</td><td>a reconciliation </td></tr>
    <tr><td class="paramname">baseArgs</td><td>class containing other arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86e35845bb6f8ad1966f339a316acb75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::traverseAllReconciliations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(DTLGraph::*)(int, vector&lt; vector&lt; MyGraph::Vertex &gt; &gt; &amp;, <a class="el" href="classDTLGraph_1_1ArgBase.html">ArgBase</a> &amp;)&#160;</td>
          <td class="paramname"><em>handleReconPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the given function on each reconciliation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>structure containing traversal specific variables </td></tr>
    <tr><td class="paramname">handleReconPtr</td><td>function to call on each reconciliation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a027401026f507f98a00b9e47c926b741"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DTLGraph::validEvent </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>eventSon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validity check for event vertices with one son (e.g. SL events).</p>
<p>If onlyCanonical is true, do not count multiple copies of events added because of artificial nodes. Specifically, do not count the following:</p><ol type="1">
<li>Duplication events with two null grandchildren.</li>
<li>Transfer events with two null grandchildren.</li>
<li>Transfer loss events with a null grandchild, and the mapping vertex preceding the TL event is associated with an artifical node (single child in species tree).</li>
<li>Null child events of the roots. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>an event vertex </td></tr>
    <tr><td class="paramname">eventSon</td><td>the mapping vertex son of event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef64cb0b45d82e727d9bf7b9cece6281"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DTLGraph::validRecNumber </td>
          <td>(</td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>eventSon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MyGraph::Vertex&#160;</td>
          <td class="paramname"><em>eventSon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the number of valid reconciliations from the two sons of the given event.</p>
<p>If not only canoncial, the sons reconciliation are multiplied. For canonical, D or T events with null children are not valid, resulting in zero reconciliations.</p>
<p>Furthermore, if suboptimal, certain conditions (e.g. 7), restrict the number of reconciliations (not currently implemented).</p>
<dl class="section return"><dt>Returns</dt><dd>number of reconciliations or zero for invalid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>an event vertex </td></tr>
    <tr><td class="paramname">eventSon1</td><td>the first mapping vertex son of event </td></tr>
    <tr><td class="paramname">eventSon2</td><td>the second mapping vertex son of event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6912bff9387b9ee1b6e1641d90038516"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DTLGraph::weightSupport </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Weight the support.</p>
<p>Finish the weighted support calculation and save it in the support property for each event vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>Epsilon of cost range for weighted calculation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa004be18e48c3c5a1e3db2cdf2f87011"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double DTLGraph::SCORE_DIFF = 0.00000000001</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>at which they are considered different. </p>
<p>Minimal difference between scores </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="DTLGraph_8h_source.html">DTLGraph.h</a></li>
<li>source/<a class="el" href="DTLGraph_8cpp.html">DTLGraph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 15 2016 19:12:46 for TERA by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
